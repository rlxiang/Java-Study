## JVM探究

- 请你谈谈你对JVM的理解？idk8和之前有什么更新
- 什么是OOM，什么是栈溢出StackOverFlowError？怎么分析？
- JVM的常用调优参数有哪些？
- 内存快照如何抓取，怎么分析Dump文件？知道吗？
- 谈谈JVM中，类加载器你的认识？



### JVM的位置

![image-20210729095415919](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210729095415919.png)

### JVM的体系结构

![image-20210729100321518](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210729100321518.png)

![image-20210729100515921](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210729100515921.png)

![image-20210729100628364](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210729100628364.png)

### 类加载器

作用： 加载Class文件

![image-20210729103542889](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210729103542889.png)

1. 虚拟机自带的加载器
2. 启动类(根)加载器
3. 扩展类加载器
4. 应用程序(系统类)加载器
5. 类加载过程
   1. 类加载器收到类加载的请求!
   2. 将这个请求向上委托给父类加载器去完成，一直向上委托，知道启动类加载器
   3. 启动加载器检查是否能够加载当前这个类，能加载就结束，使用当前的加载器，否则，抛出异常，通知子加载器进行加载4.重复步骤3

### 双亲委派机制

所谓双亲委派机制就是如果我们自定义的类与jdk的类重名了，我们自己的类是不会起作用的。因为，在类加载的过程中，一旦检测到jdk中的类和我们的写的类重名就不会起作用。（个人感觉是不会加载进内存）应用类加载器->扩展类加载器->根加载器，只要在扩展类加载器或者根加载器中有的我们自己定义的类就没有作用了

### 沙箱安全机制(了解一些即可)

​	Java安全模型的核心就是Java沙箱(sandbox)，什么是沙箱?沙箱是一个限制程序运行的环境。沙箱机制就是将Java代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。沙箱**主要限制系统资源访问**，那系统资源包括什么? CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。

​		所有的Java程序运行都可以指定沙箱，可以定制安全策略。

​	在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的ava实现中，安全依赖于沙箱(Sandbox)机制。如下图所示JDK1.0安全模型

![image-20210729135158515](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210729135158515.png)

​	但如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。因此在后续的Java1.1版本中，针对安全机制做了改进，增加了安全策略，允许用户指定代码对本地资源的访问权限。如下图所示JDK1.1`安全模型`

![image-20210729135508496](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210729135508496.png)

​	在Java1.2版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示JDK1.2安全模型

![image-20210729135615299](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210729135615299.png)

​	当前最新的安全机制实现，则引入了域(Domain)的概念。虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域(Protected Domain)，对应不一样的权限(Permission)。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示最新的安全模型(jdk 1.6)

![image-20210729135756635](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210729135756635.png)

组成沙箱的基本组件：

- `字节码校验器`(bytecode verifier):确保Java类文件遵循Java语言规范。这样可以帮助lava程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。

- 类装载器(class loader):其中类装载器在3个方面对Java沙箱起作用

  - 它防止恶意代码去干涉善意的代码;
  - 它守护了被信任的类库边界;
  - 它将代码归入保护域，确定了代码可以进行哪些操作。

  虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。

  

  类装载器采用的机制是双亲委派模式。

  1. 从最内层JVM自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用;
  2. 由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。
     - `存取控制器`(access controller):存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。
     - 安全管理器(security manager):是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。
     - 安全软件包 (security package) : java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括:
       - 安全提供者
       - 消息摘要
       - 数字签名
       - 加密
       - 鉴别



### Native

- 凡是带了native关键字的，说明java的作用范围打不到了，会去调用底层c语言的库，这样就会进入本地方法栈，调用本地方法栈里的本地接口 JNI
- JNI的作用：扩展Java的使用，融合不同的变成语言，起初是想调用c c++
- java诞生的时候 C， C++横行，想要立足，必须有调用C、C++的程序
- jvm会在内存区域中专门开辟一块标记区域：Native Method Stack，登记native方法(这里是没有执行的)，在最终执行的时候，加载本地方法库中的方法，这一过程通过JNI来调用

### PC寄存器

程序计数器:Program Counter Register

​	每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码(用来存储指向像一条指令的地址，也即将要执行的指令代码)，在执行引擎读取下一条指令，是一个非常小的内存空间，空间大小几乎可以忽略不计

### 方法区

Method Area 方法区

​	方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义,简单说，所有定义的方法的信息都保存在该区域，**此区域属于共享区间**;

​	==静态变量、常量、类信息(构造方法、接口定义)、运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关==



### 栈

栈，有时也会被叫做栈内存，主管程序的运行，生命周期和线程同步，线程结束，栈内存也就释放了，对于栈来说不存在垃圾回收问题，一旦线程结束，栈就结束了。

栈里面的东西：8大基本类型+对象引用+实例方法



栈 + 堆 + 方法区：交互关系

![image-20210731165652337](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210731165652337.png)

### 三种JVM

- Sun公司 `Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode)`
- BEA `JRockit`
- IBM `J9VM`

我们学习的都是HotSpot

### 堆

Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的。

类加载器读取了类文件后，一般会把什么东西放在堆中了？一般放类的实例，类里的方法，常量，变量~，它会保存所有引用类型的真实对象

堆内存还要细分为三个区域

- 新生区（伊甸园区） Yong/New
- 养老区 old
- 永久区 Perm

![image-20210731215712307](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210731215712307.png)

GC 垃圾回收，主要是在伊甸园区和养老区~

假设内存满了，就会OOM即，堆内存不够！

在JDK8以后，永久存储区改了个名字叫元空间

![image-20210731221215099](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210731221215099.png)

#### 新生区

- 新生区是一个类诞生和成长甚至是死亡的地方
- 新生区可以分为：
  - 伊甸园区，所有的对象都是在 **伊甸园** 区new出来的
  - 幸存者区
    - 幸存者0区
    - 幸存者1区

1. 老年区 

### 永久区

这个区域是常驻内存的。是用来存放JDK自身携带的Class对象。包括一些Interface元数据，即存储的是java运行时的一些环境或类信息，这个区域不存在垃圾回收！只有关闭JVM就会释放这个区域的内存

一个启动类，加载了大量的第三方jar包可能会使这个区域爆炸，Tomcat部署太多的应用也可能会爆炸，大量的动态生成的反射类不断被加载知道内存满就会出现OOM



- jdk1.6之前：有个永久代就是永久区，这个时候的常量池是在方法区中
- jdk1.7：也有永久代，但是慢慢的退化了，提出了`去永久代`，这时候的常量池在堆中
- jdk1.8之后：无永久代，常量池在元空间

![image-20210801152005007](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210801152005007.png)

元空间，逻辑上是存在的，但是在物理上是不存在的

```java
package com.xrl.jvm;

public class Demo02 {
    public static void main(String[] args) {
        // 返回jvm试图使用的最大内存
        long max = Runtime.getRuntime().maxMemory(); // 以字节为单位返回
        // 返回jvm总的内存大小
        long total = Runtime.getRuntime().totalMemory();// 以字节为单位返回

        System.out.println("max=" + max + "字节\t" + (max / (double) 1024 / 1024) + "MB");
        System.out.println("total=" + total + "字节\t" + (total / (double) 1024 / 1024) + "MB");


        // 默认情况下：给jvm分配的内存(也就是jvm试图使用的最大内存)是电脑内存的1/4，而初始化jvm内存是电脑的1/64
        // -Xms1024m -Xmx1024m -XX:+PrintGCDetails
        /*
            -Xms：表示jvm初始内存
            -Xmx：表示jvm的最大内存

            305664K + 699392K = 1,005,056k = 981.5MB

            OOM解决：
            1. 尝试扩大堆内存看看结果
            2. 如果还是出现错误，则分析内存，看一下代码的错误在哪(使用专业的工具JPofiler)
         */
    }
}
```

在一个项目中，突然出现了OOM错误(扩大了内存也无法解决)，该如何排除~

- 最快的方式：能够看到代码第几行出错，此时需要内存快照分析工具，MAT，Jprofiler
- 最慢的方式：Debug，一行行分析代码

**MAT，Jprofiler作用：**

- 分析Dump的内存文件（Dump文件是进程的内存镜像，可以把程序的执行状态通过调试器保存到dump文件中），快速定位内存泄露
- 获得堆中的数据
- 获得大的对象







真理：经过研究，99%的对象都是临时对象！

### Gc 垃圾回收

![image-20210801170125697](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210801170125697.png)

JVM在进行垃圾回收时，并不是对着三个区域同一回收。大部分时候，回收都是新生代~

- 新生代
- 幸存区(from,to)
- 老年区

GC两种类型：轻GC（普通GC，一般在新生代(经常)和幸存区处理（偶尔）），重GC（全局GC）

- JVM的内存模型和分区~详细到每个区放什么？
- 堆里面的分区有哪些？Eden，from，to，老年区，说说他们的特点
- GC的算法有哪些？常见的有，标记清除法，标记压缩，赋值算法，引用计数法（很少使用），怎么用？
- 轻GC和重GC分别在什么时候发生？

#### 引用计数法（为每个对象的调用都设置一个计数器，没有被调用的就清除出去，并不高效，用的不多）

![image-20210801171426453](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210801171426453.png)

#### 复制算法

新生区主要用的是复制算法，在进行GC时，会将Eden区存活的对象转移到to区，也就是往空的幸存区去存，此时如果from也有数据，也会被转移（复制）到to区，转移完成后，原来的to区就变成from区，原来的from区就变成了to区，再次GC时，又会将eden区域中的数据放在to区，from区的资源放在to区，然后to区与from区互换。赋值算法就是将to区与from区的数据进行转移和将这两个区域的身份进行互换。

![image-20210801202005110](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210801202005110.png)

绿色区域表示存活的对象![image-20210801202537400](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210801202537400.png)

- 好处：没有内存的碎片~
- 缺点：浪费了另一个内存空间，即to空间，这一空间永久是空的。假设对象100%存活，则会将from区的数据全部复制到to区，成本会很高。想要复制算法最佳使用，则就要对象存活度较低，所以复制算法主要运行在新生区。

#### 标记清除算法

标记清除算法：在GC时会扫描存活的对象，并给这些存活的对象带上标记，然后在清除的时候(此时还会在扫描一次)会将没有被标记的对象清除出去，当堆中的有效内存全部被标记了，就会停止程序，这是GC就会爆炸

![image-20210801203736212](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210801203736212.png)

缺点：两次扫描严重浪费时间，会产生内存碎片

优点：不需要额外的空间！



#### 标记压缩

标记压缩是在标记清除的基础上再次扫描空间，对标记的空间和没有标记的空间进行排序，此时就会将所有没有标记的空间连接起来，连接起来的空间就不是内存碎片了，但是多了空间移动的成本

![image-20210801204613995](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210801204613995.png)

#### 标记清除压缩

先标记清除几次，再进行压缩

![image-20210801210150815](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210801210150815.png)

![image-20210801210235646](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210801210235646.png)

### 总结

内存效率:复制算法>标记清除算法>标记压缩算法(时间复杂度)

内存整齐度:复制算法=标记压缩算法>标记清除算法

内存利用率:标记压缩算法=标记清除算法>复制算法

思考一个问题:难道没有最优算法吗?

答案:没有，没有最好的算法，只有最合适的算法----->GC:分代收集算法

年轻代：

- 存活率低
- 复制算法！

老年代：

- 区域大：存活率高
- 标记清除（内存碎片不是太多，如果多了就先清除几次，在压缩）+标记压缩混合实现



## JMM

1. 什么是JMM？

   1. JMM：就是Java Memory Model的缩写

2. 它是干嘛的？ 从官方，其他人的博客，对应的视频

   作用：缓存一致性协议，用于定义数据读写的规则（遵守，找到这个规则）

   JMM定义了线程工作内存和主内存之间的抽象关系:线程之间的共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存(Local Memory)

   ![image-20210801212438017](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210801212438017.png)

   解决共享对象可见性这个问题: volilate

3. 它该如何学习

   JMM：抽象的概念，理论

   JMM对这八种指令的使用，制定了如下规则：

   - 不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write
   - 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存
   - 不允许一个线程将没有assign的数据从工作内存同步回主内存
   - 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过assign和load操作
   - 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁
   - 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值
   - 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量
   - 对一个变量进行unlock操作之前，必须把此变量同步回主内存

   JMM对这八种操作规则和对volatile的一些特殊规则就能确定哪里操作是线程安全，哪些操作是线程不安全的了。但是这些规则实在复杂，很难在实践中直接分析。所以一般我们也不会通过上述规则进行分析。更多的时候，使用java的happen-before规则来进行分析。

   

   volilate(解决数据一致性，原子性)







