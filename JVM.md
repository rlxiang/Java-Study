## JVM探究

- 请你谈谈你对JVM的理解？idk8和之前有什么更新
- 什么是OOM，什么是栈溢出StackOverFlowError？怎么分析？
- JVM的常用调优参数有哪些？
- 内存快照如何抓取，怎么分析Dump文件？知道吗？
- 谈谈JVM中，类加载器你的认识？



### JVM的位置

![image-20210729095415919](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210729095415919.png)

### JVM的体系结构

![image-20210729100321518](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210729100321518.png)

![image-20210729100515921](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210729100515921.png)

![image-20210729100628364](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210729100628364.png)

### 类加载器

作用： 加载Class文件

![image-20210729103542889](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210729103542889.png)

1. 虚拟机自带的加载器
2. 启动类(根)加载器
3. 扩展类加载器
4. 应用程序(系统类)加载器
5. 类加载过程
   1. 类加载器收到类加载的请求!
   2. 将这个请求向上委托给父类加载器去完成，一直向上委托，知道启动类加载器
   3. 启动加载器检查是否能够加载当前这个类，能加载就结束，使用当前的加载器，否则，抛出异常，通知子加载器进行加载4.重复步骤3

### 双亲委派机制

所谓双亲委派机制就是如果我们自定义的类与jdk的类重名了，我们自己的类是不会起作用的。因为，在类加载的过程中，一旦检测到jdk中的类和我们的写的类重名就不会起作用。（个人感觉是不会加载进内存）应用类加载器->扩展类加载器->根加载器，只要在扩展类加载器或者根加载器中有的我们自己定义的类就没有作用了

### 沙箱安全机制(了解一些即可)

​	Java安全模型的核心就是Java沙箱(sandbox)，什么是沙箱?沙箱是一个限制程序运行的环境。沙箱机制就是将Java代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。沙箱**主要限制系统资源访问**，那系统资源包括什么? CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。

​		所有的Java程序运行都可以指定沙箱，可以定制安全策略。

​	在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的ava实现中，安全依赖于沙箱(Sandbox)机制。如下图所示JDK1.0安全模型

![image-20210729135158515](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210729135158515.png)

​	但如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。因此在后续的Java1.1版本中，针对安全机制做了改进，增加了安全策略，允许用户指定代码对本地资源的访问权限。如下图所示JDK1.1`安全模型`

![image-20210729135508496](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210729135508496.png)

​	在Java1.2版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示JDK1.2安全模型

![image-20210729135615299](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210729135615299.png)

​	当前最新的安全机制实现，则引入了域(Domain)的概念。虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域(Protected Domain)，对应不一样的权限(Permission)。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示最新的安全模型(jdk 1.6)

![image-20210729135756635](C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210729135756635.png)

组成沙箱的基本组件：

- `字节码校验器`(bytecode verifier):确保Java类文件遵循Java语言规范。这样可以帮助lava程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。

- 类装载器(class loader):其中类装载器在3个方面对Java沙箱起作用

  - 它防止恶意代码去干涉善意的代码;
  - 它守护了被信任的类库边界;
  - 它将代码归入保护域，确定了代码可以进行哪些操作。

  虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。

  

  类装载器采用的机制是双亲委派模式。

  1. 从最内层JVM自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用;
  2. 由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。
     - `存取控制器`(access controller):存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。
     - 安全管理器(security manager):是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。
     - 安全软件包 (security package) : java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括:
       - 安全提供者
       - 消息摘要
       - 数字签名
       - 加密
       - 鉴别



### Native

1. PC寄存器
2. 方法区
3. 栈
4. 三种JVM
5. 堆
6. 新生区、老年区
7. 永久区
8. 堆内存调优
9. Gc
   1. 常用算法
10. JMM
11. 总结







1. 百度~
2. 思维导图